#! @PERL_PATH@
#################################<rd2ch>######################################
#                                                                            #
#           This Program is part of E-CELL Simulation Environment            #
#                                                                            #
#       This program converts "Reactor Description" .rd file                 #
#               to Reactor source code of E-CELL system.                     # 
#                                                                            #
#       written by Yusuke Saito at Keio University Bioinformatics lab.       #
#                                                                            #
#      Copyright 1998-1999 by Yusuke Saito (t96406ys@sfc.keio.ac.jp)         #
#                          All Rights Reserved                               #
#                                                                            #
#                             see COPYING                                    #
#                                                                            #
##############################################################################

# if you want to set default directory, please modfy here.
$output_directory = ".";
$default_template_directory = @REACTOR_TEMPLATE_DIR@;

&search_template;
&option;
&check_filename;
&template_file;

$err_mes_td = "\n Command-line rd2ch Users: Specify a template directory with the correct absolute path.\n Makefile Users          : Check the configuration of TEMPLATEDIR in your Makefile.\n";

$err_mes_od = "Specify an output directory with an absolute path.\n";

open (RD,"$input_file[0]") || 
    die ("$input_file[0]: can't open.\nCheck the path of $input_file[0].\n");
    
&set_max_min;
&read_rd;
&check_classname;
$max_min;
close(RD);

&open_c;
&write_c;
&close_c;

&open_h;
&write_h;
&close_h;

############################# subroutine ###################################
sub search_template{
#    if (-e 'template') {
#	if (-d 'template') {
#	    $template_directory = "./template";
#	} else {
#	    print STDERR "Please remove file 'template'.\n";
#	    exit 1;
#	}
#    } else {
	$template_directory = $default_template_directory;
#    }
}

sub option{
    @ARGV2 = @ARGV;
    for($i=0;$i<=$#ARGV;$i++){
	if($ARGV[$i] eq "-h"){
	    &help;
	}
	elsif($ARGV[$i] eq "-d"){
	    $output_directory = $ARGV[$i+1];
	    $ARGV2[$i] =  "";
	    $ARGV2[$i+1] =  "";
	}
	elsif($ARGV[$i] eq "-t"){
	    $template_directory = $ARGV[$i+1];
	    $ARGV2[$i] =  "";
	    $ARGV2[$i+1] =  "";
	}
    }
    for($i=0;$i<=$#ARGV2;$i++){
	if(length($ARGV2[$i])){
	    $input_file[$k] = $ARGV2[$i];
	    $k++;
	}
    }
    print "template_directory: $template_directory\n";
    print "output_directory: $output_directory\n";
}

sub help{
    print "\n<rd2ch version 1\.1>\n";
    print "written by Yusuke Saito \(t96406ys\@sfc\.keio\.ac\.jp\)\n\n";   
    print "usage: rd2ch filename\.rd\n\n";
    print "option:     -d  output_directory\n";
    print "            -t  template_directory\n";
    exit;
}

sub check_filename{
    if($input_file[0] =~ /(.+)\.rd/){
	$filename = $1;
	$c_file = "$filename.C";
	$h_file = "$filename.h";
	unless($filename =~ /Reactor/){
            warn("warning: Classname must end with \"Reactor\"\n");
	}	
    }
    else{
	die("$input_file[0]: filename must end with .rd\n");
    }
}

sub template_file{
    $c_in = "$template_directory/reactor.C.in";
    $h_in = "$template_directory/reactor.h.in";
    $setget_in = "$template_directory/setget.C.in";
    $makeslots_in = "$template_directory/makeslots.C.in";
}

sub set_max_min{
    $map{'@MAX_SUBSTRATE'} = "INT_MAX";
    $map{'@MAX_PRODUCT'}   = "INT_MAX";
    $map{'@MAX_CATALYST'}  = "INT_MAX";
    $map{'@MAX_EFFECTOR'}  = "INT_MAX";

    $map{'@MIN_SUBSTRATE'} = 0;
    $map{'@MIN_PRODUCT'}   = 0;
    $map{'@MIN_CATALYST'}  = 0;
    $map{'@MIN_EFFECTOR'}  = 0;
}

sub read_rd{
    
    $prekey = "__UNDEFINED__";
    $keynum = 0;
    
    while($line_rd = <RD>){

	chomp $line_rd;
	
	if($line_rd =~ /^#.*/) { # do nothing at comment line
	   next; 
       } 
	
	elsif($line_rd =~ /^(([@\%])[^:]+):\s*(.*)/){
	    $keyl = $1; 
	    $keyr = $3;
	    $key_type = $2;
	    unless($keyl =~ /.([A-Z]+\d*)/){
		#keyword must be constructed by largeletter, number, _
		warn ("warning: illegal keyword [$1]. ignoring..\n");
		next;
	    }
	    if(length($map{$keyl}) != 0 && $key_type eq "@"){
		warn ("warning: duplicated keyword [$keyl]"); 
		warn ("later one applied.\n");
	    }
	    if($key_type eq "%"){
		if(length($map{$keyl}) == 0){
		    $paranum{$keyl} = 1;           
		}
		else{
		    $paranum{$keyl}++;           
		}
		@tmp = split(/\,/,$keyr);
		for($i=0 ; $i<=$#tmp ; $i++){
		    if($keyl =~ /.INCLUDE_FILE_./){
			$tmp[$i] =~ s/\s//g;
		    }
		    $property{$keyl,$paranum{$keyl},$i} = $tmp[$i];
                    if($keyl eq "%SUBSTANCE"){
			&substance;
		    }
		
		    if($keyl eq "%PARAMETER"){
			$property{$keyl,$paranum{$keyl},0} =~ s/\s//g;
			$property{$keyl,$paranum{$keyl},1} =~ s/\s//g;
		    }
		}
	    }
	    $map{$keyl} = $keyr;
	}
	
	else{
            $line_rd =~ s/^\\#/#/;
	    $map{$prekey} .="\n".$line_rd;
	}
	
	$prekey  = $keyl;
	unless(length($keyr)==0)
        {
            $keynum++;
	}
    }
    print "loaded $keynum keys from $input_file[0].\n";
    #counting the number of loaded keyword
    $map{'@VERSION'} = $property{'%VERSION',1,1};
}

sub substance{
    $property{$keyl,$paranum{$keyl},0} =~ s/\s//g;
    $property{$keyl,$paranum{$keyl},1} =~ s/\s//g;
    $property{$keyl,$paranum{$keyl},1} =~ s/inf/INT_MAX/i;
    $property{$keyl,$paranum{$keyl},2} =~ s/\s//g;
    if($property{$keyl,$paranum{$keyl},0} 
        =~ s/((Substrate|Product|Catalyst|Effector))/$1/i){
	$substance_name = uc($1); 
	unless(length($property{$keyl,$paranum{$keyl},1}) == 0){
	    $map{'@MAX_'."$substance_name"} 
	       = $property{$keyl,$paranum{$keyl},1};
	    $map{'@MIN_'."$substance_name"} 
	       = $property{$keyl,$paranum{$keyl},2};
	}
    }
    else{
     warn("warning: Illegal Substance [$property{$keyl,$paranum{$keyl},0}]\n");
    }
}

sub check_classname{
    
    if(length($map{'@CLASSNAME'})==0){warn("warning: No Classname!\n");}
#   chomp $ARGV[0];
    $map{'@CLASSNAME'} =~ s/\s//g;
#   unless($ARGV[0] =~ /$map{'@CLASSNAME'}\.rd/){
    unless($input_file[0] =~ /$map{'@CLASSNAME'}\.rd/){
	warn("warning: Filename must be Classname.rd\n");
    }
#    $map{'@CLASSNAMEL'} = uc($map{'@CLASSNAME'});
    $map{'@CLASSNAME'} = uc($map{'@CLASSNAME'});
    
    if(length($map{'@BASECLASS'})==0){warn("warning: No BaseClass!\n");}
    $map{'@BASECLASS'} =~ s/\s//g;
    $map{'@EMAIL'} =~ s/\s//g;
}

sub open_c{
    open(CIN,"$c_in") || die("$c_in: can't open\n$err_mes_td");
    open(COUT,">$output_directory/$c_file") || die("$c_file: can't open\n$err_mes_od");
    open(MAKESLOTS,"$makeslots_in") || die("$makeslots_in: can't open\n$err_mes_td");
    open(SETGET,"$setget_in") || die("$setget_in: can't open\n$err_mes_td");
}

sub write_c{

    $include=0;
    $makeslots=1;
    $setget=1;
    while($line_cin = <CIN>){
	$line_cin =~ s/#\((@[A-Z_]+)\)/$map{$1}/g;
	if($line_cin =~ /(.*)#\(%([A-Z_]+)\)(.*)/){
	   if($2 eq "INCLUDE_FILE_C"){
	       while($property{'%INCLUDE_FILE_C',1,$include}){
		   print COUT "$1";
		   print COUT "$property{'%INCLUDE_FILE_C',1,$include}";
		   print COUT "$3\n";
		   $include++;
	       }
	   }
	   
	   elsif($2 eq "MAKESLOTS"){
	       unless(length($property{'%PARAMETER',1,0}) == 0){
		   print COUT "void $map{'@CLASSNAME'}::makeSlots()\n";
		   print COUT "\{\n";
		   while($property{'%PARAMETER',$makeslots,0}){
		     $map{'@PARAMETER'} = $property{'%PARAMETER',$makeslots,0};
		     while($line_makeslots = <MAKESLOTS>){
			 $line_makeslots =~ s/#\((@[A-Z_]+)\)/$map{$1}/g;
			 print COUT "$line_makeslots";
         	     }
		     seek(MAKESLOTS,0,0);
		     $makeslots++;
		   }
		   print COUT "\}\n";
	       }
	   }
	   
	   elsif($2 eq "GET_SET"){
	       unless(length($property{'%PARAMETER',1,0}) == 0){
	         while($property{'%PARAMETER',$setget,0}){
		     $map{'@PARAMETER'} = $property{'%PARAMETER',$setget,0};
		     $map{'@TYPE'} = $property{'%PARAMETER',$setget,1};
		     while($line_setget = <SETGET>){
		         $line_setget =~ s/#\((@[A-Z_]+)\)/$map{$1}/g;
		         print COUT "$line_setget";
		     }
		     seek(SETGET,0,0);
		     $setget++;
	         }  
	       }
	   }
       }
	else{       
	    print COUT "$line_cin";
	}
    }
    print "writing $c_file ...\n";
}

sub close_c{
    close(SETGET);
    close(MAKESLOTS);
    close(COUT);
    close(CIN);
}

sub open_h{
    open(HIN,"$h_in") || die("$h_in: can't open\n$err_mes_td");
    open(HOUT,">$output_directory/$h_file") || die("$h_file: can't open\n$err_mes_od");
}

sub write_h{

    $include =  0;
    $parameter = 1;
    $object = 2;
    $setget = 1;
    while($line_hin = <HIN>){
	$line_hin =~ s/#\((@[A-Z_]+)\)/$map{$1}/g;
	if($line_hin =~ /(.*)#\(%([A-Z_]+)\)(.*)/){
	   if($2 eq "INCLUDE_FILE_H"){
	       while($property{'%INCLUDE_FILE_H',1,$include}){
		   print HOUT "$1";
		   print HOUT "$property{'%INCLUDE_FILE_H',1,$include}";
		   print HOUT "$3\n";
		   $include++;
	       }
	   }  
	   elsif($2 eq "MAKESLOTS"){           
	       unless(length($property{'%PARAMETER',1,0}) == 0){
		   print HOUT "virtual void makeSlots\(\)\;\n";
	       }
	   }

	   elsif($2 eq "PARAMETER_DECLARATION"){
	       while($property{'%PARAMETER',$parameter,0}){
		   print HOUT "$property{'%PARAMETER',$parameter,1} ";
		   print HOUT "$property{'%PARAMETER',$parameter,0}\;  ";
		   print HOUT "\/\/ [$property{'%PARAMETER',$parameter,2}]";
		   print HOUT "\, $property{'%PARAMETER',$parameter,3} \n";
		   $parameter++;
	       }
	   }
	   elsif($2 eq "OBJECT_INITIALIZATION"){
	       unless(length($property{'%PARAMETER',1,0}) == 0){
		   print HOUT "$map{'@CLASSNAME'}() : ";
		   print HOUT "$property{'%PARAMETER',1,0}(0)";
		   while($property{'%PARAMETER',$object,0}){
		       print HOUT "\,$property{'%PARAMETER',$object,0}(0)";
		       $object++;
		   }
		   print HOUT " \{makeSlots\(\)\;\} \n";
	       }
	   }
	   elsif($2 eq "SET_GET"){
	       while($property{'%PARAMETER',$setget,0}){
		   print HOUT "void set$property{'%PARAMETER',$setget,0}";
		   print HOUT "(const Message& message)\;\n";
		   print HOUT "const Message ";
		   print HOUT "get$property{'%PARAMETER',$setget,0}";
		   print HOUT "(const string& keyword)\;\n\n";
		   $setget++;
	       }
	   }
       }
	else{       
	    print HOUT "$line_hin";
	}
    }
    print "writing $h_file ...\n";
}

sub close_h{
    close(HOUT);
    close(HIN);
}

























