#!/usr/bin/env python2

from ecell.spark import *
import sys , os ,string , getopt , tempfile
import ecell.eml

class Token:
	def __init__(self, type, attr=None, filename="?" , lineno='???'):
                self.type = type
                self.attr = attr
		self.filename = filename
                self.lineno = lineno
		
	def __cmp__(self, o):
		return cmp(self.type, o)

        def __repr__(self):
                return str(self.type) + ':' + str(self.attr)
	
	def __getitem__(self,i):
		raise IndexError

	def __len__(self):
		return 0

	def info(self):
		return "File " + repr(self.filename) + ", line " + repr(self.lineno)
	def error(self):
		print "Error token", self, "(", self.info(), ")"
		raise SystemExit, 1

class AST:
	def __init__(self, type, kids=[]):
		self.type = type.type
		self.attr = type.attr
		self._kids = kids
		
	def __getitem__(self, i):
		return self._kids[i]

	def __len__(self):
		return len(self._kids)

	def __repr__(self):
                return str(self.type) + ':' + str(self._kids)

class EmScanner( GenericScanner , object ):
	
	def __init__( self ):
		GenericScanner.__init__( self )

	def tokenize( self, input ):
		self.rv = []
		self.lineno = 1
#		GenericScanner.tokenize( self, input )
                super (EmScanner, self).tokenize( input )
		return self.rv

	def t_keywords( self, s ):
		r' Reactor[\s\t] | Substance[\s\t] | Stepper[\s|\t] | System[\s\t] '
		s = string.strip( s )
		self.rv.append( Token( type=s, attr=s ) )

	def t_symbols( self, s ):
  		r' [\;\{\}\(\)\,\[\]] '
		self.rv.append( Token( type=s, attr=s ) )

	def t_number( self, s ):
		r' [+-]? ( \d+(\.\d*)? | \d*\.\d+ ) ([eE][+-]?\d+)? '
		self.rv.append( Token( type='number', attr=s ) )

	def t_name( self, s ):
		r' [a-zA-Z_/][\w\:\/\.]* '
		self.rv.append( Token( type='name', attr=s ) )

	def t_quotedstring( self, s ):
		r' "(^"|.)*" '
		self.rv.append( Token( type='quotedstring', attr=s ) )
		
	def t_comment( self, s ):
		r' \# [^\n]* '
		pass
#		self.rv.append( Token( type='comment', attr=s ) )

	def t_nl( self, s ):
		r' \n '
		self.lineno = self.lineno + 1
		pass
    
	def t_whitespace( self, s ):
		r' [\s|\t]+ '
		pass

        def t_default(self, s ):
		r' . + '
		raise ValueError, "Specification error: unmatched input: %s,line %d" % (`s`, self.lineno)


class EmParser( GenericParser ):
	def __init__( self, AST, start='start' ):

		GenericParser.__init__( self, start )

	def p_start( self, args ):
		'''
		start ::= stmts
		'''
		return AST( Token( 'start' ), args )
	
	def p_stmts_1( self, args ):
		'''
		stmts ::= stmt stmts
		'''
		return AST( Token( 'stmts' ), args )

	def p_stmts_2( self, args ):
		'''
		stmts ::= stmt
		'''
		return AST( Token( 'stmts' ), args )
	
	def p_stmt( self, args ):
		'''
		stmt ::= stepper_stmt
		stmt ::= system_stmt
		'''
		return AST( Token( 'stmt' ), args )
	
	# statements


	# object statements

	def p_stepper_stmt ( self, args ):
		'''
		stepper_stmt ::= Stepper object_decl stepper_def
		'''
		return AST( Token( 'stepper_stmt' ), args )

	def p_system_stmt ( self, args ):
                '''
		system_stmt ::= System object_decl system_def
		'''
		return AST( Token( 'system_stmt' ), args )

	def p_entity_other_stmt ( self, args ):
                '''
		entity_other_stmt ::= Substance object_decl entity_other_def
		entity_other_stmt ::= Reactor object_decl entity_other_def
		'''
		return AST ( Token( 'entity_other_stmt' ), args )

	# object declarations

	def p_object_decl( self, args ):
		'''
		object_decl ::= name ( name )
		'''
		return AST ( Token( 'object_decl' ), ( args[0], args[2] ) )

	# object definitions

	def p_stepper_def( self, args ):
		'''
		stepper_def ::= { propertylist }
		'''
		return AST ( Token( 'stepper_def' ), ( args[1], ) )

	def p_system_def( self, args ):
		'''
		system_def ::= { property_entity_list }
		'''
		return AST ( Token( 'system_def' ), ( args[1], ) )

	def p_entity_other_def( self, args ):
		'''
		entity_other_def ::= { propertylist }
		'''
		return AST ( Token( 'entity_other_def' ), ( args[1], ) )

	# property

	def p_propertylist( self, args ):
		'''
		propertylist ::= property propertylist
		'''
		return AST ( Token('propertylist'), args )

	def p_propertylist_single( self, args ):
		'''
		propertylist ::= property
		'''
		return AST ( Token('propertylist'), args )

	def p_propertylist_empty( self, args ):
		'''
		propertylist ::=
		'''
		return AST ( Token('propertylist') )

	def p_property( self, args ):
		'''
		property ::= name valuelist ;
		'''
		return AST( Token('property'), args[:2] )



	# property or entity ( for System statement )

	def p_property_entity_list( self, args ):
		'''
		property_entity_list ::= property_entity property_entity_list
		'''
		return AST( Token( 'property_entity_list' ), args )

	def p_property_entity_single( self, args ):
		'''
		property_entity_list ::= property_entity
		'''
		return AST( Token( 'property_entity_list' ), args )

	def p_property_entity_list_empty( self, args ):
		'''
		property_entity_list ::=
		'''
		return AST( Token( 'property_entity_list' ) )

	def p_property_entity( self, args ):
		'''
		property_entity ::= property
		property_entity ::= entity_other_stmt
		'''
		return AST( Token( 'property_entity' ), args )


	# value

	def p_valuelist( self, args ):
		'''
		valuelist ::= value valuelist
		'''
		return AST( Token( 'valuelist' ), args )

	def p_valuelist_single( self, args ):
		'''
		valuelist ::= value
		'''
		return AST( Token( 'valuelist' ), args )

	def p_value( self, args ):
		'''
		value ::= scalervalue
		value ::= vectorvalue
		'''
		return AST( Token( 'value' ), args )

	def p_scalervalue( self, args ):
		'''
		scalervalue ::= number
		scalervalue ::= quotedstring
		scalervalue ::= name
		'''
		return AST( Token( 'scalervalue' ), args )

	def p_vectorvalue( self, args ):
		'''
		vectorvalue ::= [ valuelist ]
		'''
		return AST( Token( 'vectorvalue' ), ( args[1], ) )



def flatten_nodetree( node ):
	aList = []

	if node == None or len( node ) == 0:
		return aList

	aList.append( node[0] )

	while len( node ) > 1:
		node = node[1]
		aList.append( node[0] )
		
	return aList

def flatten_propertytree( node ):
	anNodeList = flatten_nodetree( node )
	aList = []

	for i in anNodeList:
		if i[0].type == 'vectorvalue':
			aList.append( flatten_propertytree( i[0][0] ) )
		else:
			aList.append( i[0][0].attr )

	return aList
	


class Interpret(GenericASTTraversal):
	def __init__( self, ast, eml ):
		GenericASTTraversal.__init__( self, ast )
		self.eml = eml
		
		self.postorder()

	def n_stepper_stmt( self, node ):
		aClassname = node[1][0].attr
		anID = node[1][1].attr
		print aClassname, anID


		self.eml.createStepper( aClassname, anID )
		
		aPropertyList = []
		aPropertyNodeList = flatten_nodetree( node[2][0] )
		for i in aPropertyNodeList:
			aPropertyName = i[0].attr
			aValueNodeList = flatten_propertytree( i[1] )

			aValueList = []
			for j in aValueNodeList:
				aValueList.append( j )
			print aPropertyName, aValueList
			# self.eml.setStepperProperty( anID, aPropertyName,
			# aValueList )
			
		
		
	def default( self, node):
		pass

			
def convertEm2Eml( anEmFileObject , mode='' ):
	anEml = ecell.eml.Eml()

	# Scanning
	aScanner = EmScanner()
	aTokenList = aScanner.tokenize( anEmFileObject.read() )
	if mode == 'debug':print aTokenList

	# Parsing 
	aParser = EmParser( AST )
	anAst = aParser.parse( aTokenList )
	if mode == 'debug':print 'AST:', anAst

	# Generating
	anInterpreter = Interpret( anAst, anEml )

	aString = anEml.asString()
	    
	return anEml

def convert2FullID( anEml, aType, aSystemID ):

        aFullID = anEml.convertSystemID2SystemFullID(aSystemID)
        if aType == 'System':
		anID = aFullID
	elif aType == 'Substance':
		anID = 'Substance:' + aSystemID
	elif aType == 'Stepper':
		anID = aSystemID
	elif aType == 'Reactor':
		anID = 'Reactor:' + aSystemID
	else:
		raise ValueError, 'Type Error %s %s %s' (aType, aClass, aSystemID)
	    
	return anID
    
    
def usage():
	sys.stderr.write("""\
Usage: em2eml.py [options] <filename>
       default automatic rename mode (*.em -> *.eml) 

Valid options:
  -f      stdout mode
""")
if __name__ == '__main__':
	try:
		opts , args = getopt.getopt(sys.argv[1:] , 'fD')
	except:
		usage()
		sys.exit(0)
		
	mode = ''
	for (opt , value ) in opts:
		if opt == '-D':
			mode = 'debug'
		if opt == '-f':
			mode = 'stdout'
	if not args:
		args.append('-')
	for filename in args:
		if filename == '-':
			anEmFile = sys.stdin
		else:
			anEmFilename = filename
			anEmFile = open( anEmFilename, 'r')
			
	anEmlObject = convertEm2Eml(anEmFile, mode=mode)
	aString = anEmlObject.asString()
	
	if mode == 'stdout' or mode == 'debug':
		print aString
	else:
		anOutputFilename =  string.join(string.split(anEmFilename, '.em'), '.eml')
		anOutput = open(anOutputFilename, 'w')
		anOutput.write(aString)
		anOutput.close()
		

		

	
