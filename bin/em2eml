#!/usr/bin/env ecell3

"""
A program for converting .em file to EML.
This program is part of E-Cell Simulation Environment Version 3.
"""

__program__ = 'em2eml'
__version__ = '0.3'
__author__ = 'Kentarou Takahashi and Kouichi Takahashi <shafi@e-cell.org>'
__copyright__ = 'Copyright (C) 2002 Keio University'
__license__ = 'GPL'


import sys
import os
import string 
import getopt
import tempfile

import ecell.eml
from ecell.spark import *


class Token:
	def __init__(self, type, attr=None, filename="?" , lineno='???'):
                self.type = type
                self.attr = attr
		self.filename = filename
                self.lineno = lineno
		
	def __cmp__(self, o):
		return cmp(self.type, o)

        def __repr__(self):
                return str(self.type) + ':' + str(self.attr)
	
	def __getitem__(self,i):
		raise IndexError

	def __len__(self):
		return 0

	def info(self):
		return "File " + repr(self.filename) + ", line " + repr(self.lineno)
	def error(self):
		print "Error token", self, "(", self.info(), ")"
		raise SystemExit, 1

class AST:
	def __init__(self, type, kids=[]):
		self.type = type.type
		self.attr = type.attr
		self._kids = kids
		
	def __getitem__(self, i):
		return self._kids[i]

	def __len__(self):
		return len(self._kids)

	def __repr__(self):
                return str(self.type) + ':' + str(self._kids)

class EmScanner( GenericScanner , object ):
	
	def __init__( self ):
		GenericScanner.__init__( self )

	def tokenize( self, input ):
		self.rv = []
		self.lineno = 1
		self.filename = '???'
#		GenericScanner.tokenize( self, input )
                super (EmScanner, self).tokenize( input )
		return self.rv

	def createToken( self, type, attr=None ):
		return Token( type, attr, self.filename, self.lineno )

	def t_keywords( self, s ):
		r' Process[\s\t] | Variable[\s\t] | Stepper[\s|\t] | System[\s\t] '
		s = string.strip( s )
		self.rv.append( self.createToken( s, s ) )

	def t_symbols( self, s ):
  		r' [\;\{\}\(\)\,\[\]] '
		self.rv.append( self.createToken( s, s ) )

	def t_number( self, s ):
		r' [+-]?(\d+(\.\d*)?|\d*\.\d+)([eE][+-]?\d+)? '
		self.rv.append( self.createToken( 'number', s ) )

	def t_name( self, s ):
		r' [a-zA-Z_/][\w\:\/\.]* '
		self.rv.append( self.createToken( 'name', s ) )

	def t_quotedstring( self, s ):
		r' "(^"|.)*" '
		self.rv.append( self.createToken( 'quotedstring', s ) )
		
	def t_control( self, s ):
		r' \%line [^\n]*\n '
		seq = s.split()
		self.lineno = int( seq[1] )
		self.filename = str( seq[2] )

	def t_comment( self, s ):
		r' \# [^\n]* '
		pass
#		self.rv.append( self.createToken( type='comment', attr=s ) )

	def t_nl( self, s ):
		r' \n '
		self.lineno = self.lineno + 1
    
	def t_whitespace( self, s ):
		r' [ |\t]+ '
		pass

        def t_default(self, s ):
		r' .+ '
		raise ValueError, "Unexpected error: unmatched input: %s, line %d." % (self.filename, self.lineno)


class EmParser( GenericParser ):
	def __init__( self, AST, start='start' ):

		GenericParser.__init__( self, start )

	def p_start( self, args ):
		'''
		start ::= stmts
		'''
		return AST( Token( 'start' ), args )
	
	def p_stmts( self, args ):
		'''
		stmts ::= stmt stmts
		stmts ::= stmt
		stmts ::=
		'''
		return AST( Token( 'stmts' ), args )

	def p_stmt( self, args ):
		'''
		stmt ::= stepper_stmt
		stmt ::= system_stmt
		'''
		return AST( Token( 'stmt' ), args )
	
	# statements


	# object statements

	def p_stepper_stmt ( self, args ):
		'''
		stepper_stmt ::= Stepper object_decl stepper_def
		'''
		return AST( Token( 'stepper_stmt' ), args )

	def p_system_stmt ( self, args ):
                '''
		system_stmt ::= System object_decl system_def
		'''
		return AST( Token( 'system_stmt' ), args )

	def p_entity_other_stmt ( self, args ):
                '''
		entity_other_stmt ::= Variable object_decl entity_other_def
		entity_other_stmt ::= Process object_decl entity_other_def
		'''
		return AST ( Token( 'entity_other_stmt' ), args )

	# object declarations

	def p_object_decl( self, args ):
		'''
		object_decl ::= name ( name )
		object_decl ::= Variable ( name )
		'''
		return AST ( Token( 'object_decl' ), ( args[0], args[2] ) )

	# object definitions

	def p_stepper_def( self, args ):
		'''
		stepper_def ::= { propertylist }
		'''
		return AST ( Token( 'stepper_def' ), ( args[1], ) )

	def p_system_def( self, args ):
		'''
		system_def ::= { property_entity_list }
		'''
		return AST ( Token( 'system_def' ), ( args[1], ) )

	def p_entity_other_def( self, args ):
		'''
		entity_other_def ::= { propertylist }
		'''
		return AST ( Token( 'entity_other_def' ), ( args[1], ) )

	# property

	def p_propertylist( self, args ):
		'''
		propertylist ::= property propertylist
		propertylist ::= property
		propertylist ::=
		'''
		return AST ( Token('propertylist'), args )

	def p_property( self, args ):
		'''
		property ::= name valuelist ;
		'''
		return AST( Token('property'), args[:2] )



	# property or entity ( for System statement )

	def p_property_entity_list( self, args ):
		'''
		property_entity_list ::= property_entity property_entity_list
		property_entity_list ::= property_entity
		property_entity_list ::=
		'''
		return AST( Token( 'property_entity_list' ), args )

	def p_property_entity( self, args ):
		'''
		property_entity ::= property
		property_entity ::= entity_other_stmt
		'''
		return AST( Token( 'property_entity' ), args )


	# value

	def p_valuelist( self, args ):
		'''
		valuelist ::= value valuelist
		valuelist ::= value
		'''
		return AST( Token( 'valuelist' ), args )

	def p_value( self, args ):
		'''
		value ::= scalervalue
		value ::= vectorvalue
		'''
		return AST( Token( 'value' ), args )

	def p_scalervalue( self, args ):
		'''
		scalervalue ::= number
		scalervalue ::= quotedstring
		scalervalue ::= name
		'''
		return AST( Token( 'scalervalue' ), args )

	def p_vectorvalue( self, args ):
		'''
		vectorvalue ::= [ valuelist ]
		'''
		return AST( Token( 'vectorvalue' ), ( args[1], ) )


	def error( self, token ):
		sys.stderr.write( "Syntax error at or near token '%s', line %d of file %s.\n" % ( token.attr, token.lineno, token.filename ) )
		raise SystemExit


def flatten_nodetree( node ):
	aList = []

	if node is None or len( node ) == 0:
		return aList

	aList.append( node[0] )

	while len( node ) > 1:
		node = node[1]
		if len( node ) == 0:
			break
		else:
			aList.append( node[0] )
		
	return aList

def flatten_propertytree( node ):
	anNodeList = flatten_nodetree( node )
	aList = []

	for i in anNodeList:
		if i[0].type == 'vectorvalue':
			aList.append( flatten_propertytree( i[0][0] ) )
		else:
			aList.append( i[0][0].attr )

	return aList
	


class Interpret(GenericASTTraversal):
	def __init__( self, ast, eml ):
		GenericASTTraversal.__init__( self, ast )
		self.eml = eml
		
		self.postorder()

	def n_stepper_stmt( self, node ):
		aClassname = node[1][0].attr
		anID = node[1][1].attr

		self.eml.createStepper( aClassname, anID )
		
		aPropertyList = []
		aPropertyNodeList = flatten_nodetree( node[2][0] )
		for i in aPropertyNodeList:
			aPropertyName = i[0].attr

			aValueNodeList = flatten_propertytree( i[1] )

			aValueList = []
			for j in aValueNodeList:
				aValueList.append( j )

			self.eml.setStepperProperty( anID, aPropertyName,\
						     aValueList )

	def n_system_stmt( self, node, path='' ):
		aType = node[0].attr
		aClassname = node[1][0].attr
		anID = node[1][1].attr
		if path != '':
			anID = path + ':' + anID

		aFullID = convert2FullID( self.eml , aType, anID)
		self.eml.createEntity( aClassname, aFullID )
		
		aPropertyNodeList = flatten_nodetree( node[2][0] )
		for i in aPropertyNodeList:
			if len(i[0]) != 0: 
				aPropertyName = i[0][0].attr
			else:
				aPropertyName = i[0].attr

			if aType == 'System' and\
			       aPropertyName in ( 'Variable', 'Process' ):
				self.n_system_stmt(i[0], anID)
				continue
			
			if len(i[0]) != 0:
				aValueList = flatten_propertytree( i[0][1] )
			else:
				aValueList = flatten_propertytree( i[1] )

			self.eml.setEntityProperty( aFullID, aPropertyName,\
						    aValueList )
		
	def default( self, node):
		pass

			
def convertEm2Eml( anEmFileObject, debug=0 ):

	anEml = ecell.eml.Eml()

	# Scanning
	aScanner = EmScanner()
	aTokenList = aScanner.tokenize( anEmFileObject.read() )
	if debug != 0:print aTokenList

	# Parsing 
	aParser = EmParser( AST )
	anAst = aParser.parse( aTokenList )
	if debug != 0:print 'AST:', anAst

	# Generating
	anInterpreter = Interpret( anAst, anEml )

	aString = anEml.asString()
	    
	return anEml

def convert2FullID( anEml, aType, aSystemID ):

        if aType == 'System':
		#FIXME: convertSystemID2SystemFullID() will be deprecated
		return ecell.eml.convertSystemID2SystemFullID( aSystemID )
	elif aType == 'Variable':
		return 'Variable:' + aSystemID
	elif aType == 'Process':
		return 'Process:' + aSystemID

	# error
	raise ValueError, 'Type Error in conver2FullID() (%s)' % aType
    


#
# preprocessing methods
#

import StringIO

import ecell.em
em = ecell.em ; del ecell.em



class Preprocessor:

	def __init__( self, file, filename ):
		self.need_linecontrol = 0
		self.file = file
		self.filename = filename
		self.interpreter = None

	def __del__( self ):
		self.shutdown()

	def lineControl( self, interpreter, file, line ):
		interpreter.write( '%%line %d %s\n' % ( line, file ) )

	def needLineControl( self, *args ):
		self.need_linecontrol = 1

	def atParseHook( self, interpreter, keywords ):
		if not self.need_linecontrol:
			return

		( file, line ) = interpreter.context().identify()
		self.lineControl( interpreter, file, line )
		self.need_linecontrol = 0

	def beforeIncludeHook( self, interpreter, keywords ):
		self.lineControl( interpreter, keywords['name'], 1 )

	def afterIncludeHook( self, interpreter, keywords ):
		( file, line ) = interpreter.context().identify()
		self.lineControl( interpreter, file, line )

	def preprocess( self ):

		#
		# init
		#
		Output = StringIO.StringIO()
		self.interpreter = em.Interpreter( output = Output )
		pseudo = self.interpreter.pseudo
		pseudo.flatten()

		#
		# set hooks
		#
		pseudo.addHook( 'after_include',     self.afterIncludeHook )
		pseudo.addHook( 'before_include',    self.beforeIncludeHook )
		pseudo.addHook( 'after_expand',      self.needLineControl )
		pseudo.addHook( 'after_evaluate',    self.needLineControl )
		pseudo.addHook( 'after_execute',     self.needLineControl )
		pseudo.addHook( 'after_substitute',  self.needLineControl )
		pseudo.addHook( 'after_significate', self.needLineControl )
		pseudo.addHook( 'at_parse',          self.atParseHook )


		#
		# processing
		#

		# write first line
		self.lineControl( self.interpreter, self.filename, 1 )

		if self.file is not None:
			self.interpreter.wrap( self.interpreter.file,\
					  ( self.file, self.filename ), 0, 1 )

		self.interpreter.flush()

		return Output


	def shutdown( self ):
		
		self.interpreter.shutdown()



def usage():
	aProgramName = os.path.basename( sys.argv[0] )
	print '''
%s -- convert em to eml

Usage: %s [-h] [-f] [-o outfile] infile
       default automatic rename mode (*.em -> *.eml) 

Options:
        -h or --help       :  Print this message.
        -f or --force      :  Force overwrite even if outfile already exists.
        -o or --outfile=   :  Specify output file name.  '-' means stdout.
        -E or --preprocess :  Preprocessing only. implies -o -.
''' % ( aProgramName, aProgramName )
	


def main():

	try:
		opts , args = getopt.getopt( sys.argv[1:] , 'DEhfo:',
					     ["help", "force", "outfile=",
					      "preprocess"])
	except:
		usage()
		sys.exit(1)

	anEmlFileName = None
	aForceFlag = 0
	debug = 0
	preprocessing_only = 0
	for anOption, anArg in opts:
		if anOption in ( "-h", '--help' ):
			usage()
			sys.exit(0)
			
		if anOption in ( "-D", '--debug' ):
			debug = 1
			
		if anOption in ( "-o", '--outfile'):
		        anEmlFileName = anArg

		if anOption in ( "-E", '--preprocess'):
			preprocessing_only = 1
                        anEmlFileName = '-'			

        if len( args ) == 0:
		sys.stderr.write( "No input file.\n" )
		sys.exit( 1 )

	if args[0] == '-':
		anEmlFileName = '-'
		anEmFileName = args[1]
	else:
		anEmFileName = args[0]
		anEmFile = open( anEmFileName, 'r' )

	aBaseName = os.path.basename( anEmFileName )
	aBaseName, anExt = os.path.splitext( aBaseName )

	if anEmlFileName == None:
		if anExt == '.em':
			anExt = '.eml'
		else:
			anExt += '.eml'

		anEmlFileName = aBaseName + anExt

	if anEmlFileName == '-':
		anEmlFile = sys.stdout

	aPreprocessor = Preprocessor( anEmFile, anEmFileName )
	aTempFile = aPreprocessor.preprocess()

	aTempFile.seek( 0 )

	if preprocessing_only != 0:
		anEmlFile.write( aTempFile.read() )
		aTempFile.close()
		anEmlFile.close()
		sys.exit(0)

	anEmlObject = convertEm2Eml( aTempFile, debug )
	aTempFile.close()
	del aPreprocessor

	aString = anEmlObject.asString()
	
        if anEmlFileName == '-':
		print aString
	else:
		anEmlFile = open(anEmlFileName, 'w')
		anEmlFile.write(aString)
		anEmlFile.close()
		


if __name__ == '__main__':
	main()
