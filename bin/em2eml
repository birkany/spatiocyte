#!/usr/bin/env python2

from spark import *
import sys , os ,string , getopt , tempfile
import eml

class Token:
	def __init__(self, type, attr=None, lineno='???'):
                self.type = type
                self.attr = attr
                self.lineno = lineno
		
	def __cmp__(self, o):
		return cmp(self.type, o)

        def __repr__(self):
                return str(self.type)


class AST:
        def __init__(self, type, left=None, right=None):
                self.type = type.type
                self.attr = type.attr
                self._kids = []
                self.left = left
                self.right = right
                if left: self._kids.append(left)
                if right: self._kids.append(right)

        def __getitem__(self, i):
                return self._kids[i]

	def __repr__(self):
                return str(self.type)

class EmScanner( GenericScanner , object ):
	
	def __init__( self ):
		GenericScanner.__init__( self )

	def tokenize( self, input ):
		self.rv = []
		self.lineno = 1
#		GenericScanner.tokenize( self, input )
                super (EmScanner, self).tokenize( input )
		return self.rv

	def t_keywords( self, s ):
		r' Reactor | Reactant | Substance | Stepper | System | root '
		self.rv.append( Token( type=s, attr=s ) )

	def t_symbols( self, s ):
  		r' [\;\{\}\(\)\,] '
		self.rv.append( Token( type=s, attr=s ) )

	def t_number( self, s ):
		r' [+-]? ( \d+(\.\d*)? | \d*\.\d+ ) ([eE][+-]?\d+)? '
		self.rv.append( Token( type='number', attr=s ) )

	def t_name( self, s ):
		r' [a-zA-Z_/][\w\:\/\.]* '
		self.rv.append( Token( type='name', attr=s ) )

	def t_quotedstring( self, s ):
		r' "(^"|.)*" '
		self.rv.append( Token( type='quotedstring', attr=s ) )
		
	def t_comment( self, s ):
		r' \# [^\n]* '
		pass
#		self.rv.append( Token( type='comment', attr=s ) )
		
	def t_nl( self, s ):
		r'\n'
		self.lineno = self.lineno + 1
    
	def t_whitespace( self, s ):
		r' [\s|\t]+ '
		pass

        def t_default(self, s ):
		r' . + '
		raise ValueError, "Specification error: unmatched input: %s,line %d" % (`s`, self.lineno)


class EmParser( GenericParser ):
	def __init__( self, start='start' ):
		GenericParser.__init__( self, start )

	def p_start( self, args ):
		'''
		start ::= stmts
		'''
		return args[0]
	
	def p_stmts_1( self, args ):
		'''
		stmts ::= stmts entity_type entity
		'''
		return AST ( type=args[1] ,left=args[0], right=args[2] )

	def p_stmts_2( self, args ):
		'''
		stmts ::= stmt
		'''
		return args[0]
	
	def p_stmt( self, args ):
		'''
		stmt ::= entity_type entity
		'''
		return AST( type=args[0] , right=args[1] )

	def p_entity_tpye_ste( self, args ):
		'''
		entity_type ::= Stepper
		entity_type ::= System
		entity_type ::= Substance
		entity_type ::= Reactor
		'''
		return AST( type=args[0] )
	
	def p_entity_stepper ( self, args ):
		'''
		entity ::= class ( id ) { } 
		'''
		return AST( type=args[1] , left=args[0], right=args[2] )

	def p_entity_system ( self, args ):
                '''
		entity ::= class ( systembase
		'''
		return AST( type=args[1] , left=args[0], right=args[2] )

	def p_systembase_1 ( self, args ):
		'''
		systembase ::= systemidandinfo ) { propertylist }
		'''
		return AST( type=args[2], left=args[0], right=args[3] )

	def p_systemidandinfo ( self, args ):
		'''
		systemidandinfo ::= systemid , info
		'''
		return AST( type=args[1], left=args[0], right=args[2] )

	def p_systeminfo_1( self, args):
		'''
		systeminfo ::= systemid , info ) { propertylist }
		'''
		return AST( type=args[4], left=args[0] , right=args[5] )

	def p_class ( self, args ):
		'''
		class ::= name
		class ::= System
		class ::= Stepper
		class ::= Substance
		class ::= Reactor
		'''
		return AST ( type=args[0] )

	def p_id ( self , args ):
		' id ::= name '
		return AST ( type=args[0] )

	def p_systemid( self, args ):
		' systemid ::= name '
		return AST ( type=args[0] )

	def p_info( self, args ):
		' info ::= quotedstring '
		return AST ( type=args[0])
	
	def p_entitylist_1( self, args ):
		'''
		entitylist ::= entity class entitylist
		'''
		return AST ( type=args[1] , left=args[0], right=args[2] )
	
	def p_entitylist_2( self, args):
		'''
		entitylist ::= entity
		'''
		return args[0]

	def p_propertylist_1( self, args ):
		'''
		propertylist ::= property ; propertylist
		'''
		return AST( type=args[1], left=args[0] , right=args[2] )

	def p_propertylist_2( self, args ):
		'''
		propertylist ::= property
		'''
		return args[0]
	
	def p_propertylist_3( self, args ):
		'''
		propertylist ::= propertylist entity_type entitylist
		'''
		return AST( type=args[1], left=args[0], right=args[2] )
	
	def p_property_1( self, args ):
		'''
		property ::= propertyname valuelist
		'''
		return AST( type=args[0] , right=args[1] )
	
	def p_property_2( self, args ):
		'''
		property ::= property ;
		'''
		return AST ( type=args[1] , left=args[0] , right=args[0] )
	
	def p_propertyname( self, args ):
		'''
		propertyname ::= name
		propertyname ::= Stepper
		propertyname ::= Reactant
		'''
		return AST( type=args[0] )
	
	def p_valuelist_1( self, args ):
		'''
		valuelist ::= value valuelist
		'''
		return AST( type=args[0] , right=args[1] )

	def p_valuelist_2( self, args ):
		'''
		valuelist ::= value
		'''
		return AST( type=args[0] )
	
	def p_value( self, args ):
		'''
		value ::= number
		value ::= quotedstring
		value ::= name
		'''
		return AST( type=args[0] )

class Interpret(GenericASTTraversal):
	def __init__( self, ast ):
		GenericASTTraversal.__init__( self, ast )
		
		# eml stack
		self.queue = []
		
		self.postorder()
		ast.value = self.queue
		#print ast.value

	def n_number( self, node):
		node.value = node.attr

        def n_name( self, node):
		node.value = node.attr

	def n_quotedstring(self, node):
		node.value = node.attr
		
	def n_Stepper( self, node ):
		node.value = node.attr
		if node.right != None and node.right.type != 'name':
			aList = [node.value] + node.right.value
			self.queue.append(aList)

	def n_System( self, node):
		node.value = node.attr
		if node.right != None:
			aList = [node.value] + node.right.value
			self.queue.append(aList)

	def n_Reactor( self, node):
		node.value = node.attr
		if node.right != None:
			aList = [node.value] + node.right.value
			self.queue.append(aList)
		
	def n_Substance( self, node):
		node.value = node.attr
		if node.right != None:
			aList = [node.value] + node.right.value
			self.queue.append(aList)
		
	def n_Reactant( self, node):
		node.value = node.attr
		
	def default( self, node):
#               left  = node.left.value
#		right = node.right.value

		if node.type == '(':
			aClass = node.left.value
			if node.left.type == 'name' and node.right.type == 'name':
				anID = node.right.value
			else:
				aSystemID = node.right.left.left.value
                                anID = aSystemID			
			node.value = [aClass, anID, node.right.value]

		elif ( node.type == '{' ):
			aSystemID = node.left.left.value
			aPropertyList = []
			nodekid = node.right
			while nodekid.type == ';':
				aPropertyList.append(nodekid.value)
				nodekid = nodekid.right
			node.value = aPropertyList
			
		elif ( node.type == ',' ):
			node.value = node.attr
				
		elif ( node.type == ';' ):
			aValueList = []
			nodepro = node.left.right
			while hasattr(nodepro, 'value'):
				aValueList.append(nodepro.value)
				nodepro = nodepro.right
			aPropertyName = node.left.value
			node.value = (aPropertyName, aValueList)
		
		else:
			print "Syntaxerror..%s %s" % (node.type, node.attr)
			node.value = node.attr
			
def convertEm2Eml( anEmFileObject , mode='' ):
	# template EmlFile generate
	tempFilename = tempfile.mktemp()
	tempFile = open(tempFilename, 'w')
	tempFile.write('<?xml version="1.0" ?><eml><stepperlist/></eml>')
	tempFile.close()
	anEml = eml.Eml( open(tempFilename) )

	# Scanning
	aScanner = EmScanner()
	aTokenList = aScanner.tokenize( anEmFileObject.read() )
	if mode == 'debug':print aTokenList

	# Parsing 
	aParser = EmParser()
	anAst = aParser.parse( aTokenList )
	if mode == 'debug':print 'AST:', anAst

	# Generating
	anInterpreter = Interpret( anAst )
	aQueueList = sortSystemID(anInterpreter.queue)
	if mode == 'debug':print aQueueList

	for part in aQueueList:
                (aType, aClass, anID, aPropertyList) = part[0], part[1], part[2], part[3:]
		aFullID = convert2FullID(anEml, aType,  anID)
		if aType == 'Stepper':
			anEml.createStepper(aClass, aFullID)
			if mode == 'debug':print "createStepper(%s, %s)" % (aClass, aFullID)
			continue
		else:
			anEml.createEntity(aClass, aFullID)
			if mode == 'debug':print "createEntity(%s, %s)" % (aClass, anID)

		for i in aPropertyList:
			for j in i:
				(aPropertyName, aValueList) = j[0], j[1:]
				anEml.setEntityProperty(aFullID, aPropertyName, aValueList)
				if mode == 'debug':print "\tsetEntityProperty(%s, %s, %s)" % (aFullID, aPropertyName, aValueList)


	aString = anEml.asString()
	    
	os.unlink(tempFilename)

	return anEml

def convert2FullID( anEml, aType, aSystemID ):

        aFullID = anEml.convertSystemID2SystemFullID(aSystemID)
        if aType == 'System':
		anID = aFullID
	elif aType == 'Substance':
		anID = 'Substance:' + aSystemID
	elif aType == 'Stepper':
		anID = aSystemID
	elif aType == 'Reactor':
		anID = 'Reactor:' + aSystemID
	else:
		raise ValueError, 'Type Error %s %s %s' (aType, aClass, aSystemID)
	    
	return anID
    
def sortSystemID( aList ):
	aSortList  = []
	aLowList   = []
	aHightList = []
	for i in aList:
                aType = i[0]
		if aType == 'System' or aType == 'Stepper':
			aHightList.append(i)
		else:
			aLowList.append(i)
		aSortList = aHightList + aLowList
	    
	return aSortList
    
def usage():
	sys.stderr.write("""\
Usage: em2eml.py [options] <filename>
       default automatic rename mode (*.em -> *.eml) 

Valid options:
  -f      stdout mode
""")
if __name__ == '__main__':
	try:
		opts , args = getopt.getopt(sys.argv[1:] , 'fD')
	except:
		usage()
		sys.exit(0)
		
	mode = ''
	for (opt , value ) in opts:
		if opt == '-D':
			mode = 'debug'
		if opt == '-f':
			mode = 'stdout'
	if not args:
		args.append('-')
	for filename in args:
		if filename == '-':
			anEmFile = sys.stdin
		else:
			anEmFilename = filename
			anEmFile = open( anEmFilename, 'r')
			
	anEmlObject = convertEm2Eml(anEmFile, mode=mode)
	aString = anEmlObject.asString()
	
	if mode == 'stdout' or mode == 'debug':
		print aString
	else:
		anOutputFilename =  string.join(string.split(anEmFilename, '.em'), '.eml')
		anOutput = open(anOutputFilename, 'w')
		anOutput.write(aString)
		anOutput.close()
		

		

	
