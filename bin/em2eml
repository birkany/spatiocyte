#!/usr/bin/env python2

from spark import *
import sys
import string 
import eml

class Token:
	def __init__(self, type, attr=None, lineno='???'):
                self.type = type
                self.attr = attr
                self.lineno = lineno
		
	def __cmp__(self, o):
		return cmp(self.type, o)
        ###
        def __repr__(self):
                return str(self.type)


class AST:
        def __init__(self, type, left=None, right=None):
                self.type = type.type
                self.attr = type.attr
                self._kids = []
                self.left = left
                self.right = right
                if left: self._kids.append(left)
                if right: self._kids.append(right)

        def __getitem__(self, i):
                return self._kids[i]

	def __repr__(self):
                return str(self.type)

class ErScanner( GenericScanner ):
	
	def __init__( self ):
		GenericScanner.__init__( self )

	def tokenize( self, input ):
		self.rv = []
		GenericScanner.tokenize( self, input )
		return self.rv

	def t_keywords( self, s ):
		r' Reactor | Reactant | Substance | Stepper | System | root '
		self.rv.append( Token( type=s, attr=s ) )

	def t_symbols( self, s ):
  		r' [\;\{\}\(\)\,] '
		self.rv.append( Token( type=s, attr=s ) )

	def t_number( self, s ):
		r' [+-]? ( \d+(\.\d*)? | \d*\.\d+ ) ([eE][+-]?\d+)? '
		self.rv.append( Token( type='number', attr=s ) )

	def t_name( self, s ):
		r' [a-zA-Z_/][\w\:\/\.]* '
		self.rv.append( Token( type='name', attr=s ) )

	def t_quotedstring( self, s ):
		r' "(^"|.)*" '
		self.rv.append( Token( type='quotedstring', attr=s ) )
    
	def t_whitespace( self, s ):
		r' \s+ '
		pass
#		self.rv.append( Token( type='space', attr=s ) )

	def t_comment( self, s ):
		r' \# [^\n|\r]* '
		pass
#		self.rv.append( Token( type='comment', attr=s ) )



class ErParser( GenericParser ):
	def __init__( self, start='start' ):
		GenericParser.__init__( self, start )

	def p_start( self, args ):
		'''
		start ::= stmts
		'''
		return args[0]
	
	def p_stmts_1( self, args ):
		'''
		stmts ::= stmts entity_type entity
		'''
		return AST ( type=args[1] ,left=args[0], right=args[2] )

	def p_stmts_2( self, args ):
		'''
		stmts ::= stmt
		'''
		return args[0]
	
	def p_stmt( self, args ):
		'''
		stmt ::= entity_type entity
		'''
		return AST( type=args[0] , right=args[1] )

	def p_entity_tpye_ste( self, args ):
		'''
		entity_type ::= Stepper
		entity_type ::= System
		entity_type ::= Substance
		entity_type ::= Reactor
		'''
		return AST( type=args[0] )
	
	def p_entity_stepper ( self, args ):
		'''
		entity ::= class ( id ) { } 
		'''
		return AST( type=args[1] , left=args[0], right=args[2] )

	def p_entity_system ( self, args ):
                '''
		entity ::= class ( systembase
		'''
		return AST( type=args[1] , left=args[0], right=args[2] )

	def p_systembase_1 ( self, args ):
		'''
		systembase ::= systemidandinfo ) { propertylist }
		'''
		return AST( type=args[2], left=args[0], right=args[3] )

	def p_systemidandinfo ( self, args ):
		'''
		systemidandinfo ::= systemid , info
		'''
		return AST( type=args[1], left=args[0], right=args[2] )

	def p_systeminfo_1( self, args):
		'''
		systeminfo ::= systemid , info ) { propertylist }
		'''
		return AST( type=args[4], left=args[0] , right=args[5] )

	def p_class ( self, args ):
		'''
		class ::= name
		class ::= System
		class ::= Stepper
		class ::= Substance
		class ::= Reactor
		'''
		return AST ( type=args[0] )

	def p_id ( self , args ):
		' id ::= name '
		return AST ( type=args[0] )

	def p_systemid( self, args ):
		' systemid ::= name '
		return AST ( type=args[0] )

	def p_info( self, args ):
		' info ::= quotedstring '
		return AST ( type=args[0])
	
	def p_entitylist_1( self, args ):
		'''
		entitylist ::= entity class entitylist
		'''
		return AST ( type=args[1] , left=args[0], right=args[2] )
	
	def p_entitylist_2( self, args):
		'''
		entitylist ::= entity
		'''
		return args[0]

	def p_propertylist_1( self, args ):
		'''
		propertylist ::= property ; propertylist
		'''
		return AST( type=args[1], left=args[0] , right=args[2] )

	def p_propertylist_2( self, args ):
		'''
		propertylist ::= property
		'''
		return args[0]
	
	def p_propertylist_3( self, args ):
		'''
		propertylist ::= propertylist entity_type entitylist
		'''
		return AST( type=args[1], left=args[0], right=args[2] )
	
	def p_property_1( self, args ):
		'''
		property ::= propertyname valuelist
		'''
		return AST( type=args[0] , right=args[1] )
	
	def p_property_2( self, args ):
		'''
		property ::= property ;
		'''
		return AST ( type=args[1] , left=args[0] , right=args[0] )
	
	def p_propertyname( self, args ):
		'''
		propertyname ::= name
		propertyname ::= Stepper
		propertyname ::= Reactant
		'''
		return AST( type=args[0] )
	
	def p_valuelist_1( self, args ):
		'''
		valuelist ::= value valuelist
		'''
		return AST( type=args[0] , right=args[1] )

	def p_valuelist_2( self, args ):
		'''
		valuelist ::= value
		'''
		return AST( type=args[0] )
	
	def p_value( self, args ):
		'''
		value ::= number
		value ::= quotedstring
		value ::= name
		'''
		return AST( type=args[0] )

class Interpret(GenericASTTraversal):
	def __init__( self, ast ):
		GenericASTTraversal.__init__( self, ast )
		self.postorder()
		#print ast.value

	def n_number( self, node):
		node.value = node.attr

        def n_name( self, node):
		node.value = node.attr

	def n_Stepper( self, node ):
		node.value = node.attr

	def n_System( self, node):
		node.value = node.attr

	def default( self, node):
#		right = node.right.value
#		print "(node.type, right)=\t", node.type, right

		if node.type == '(':
			aClass = node.left.value
			if node.left.type == 'name' and node.right.type == 'name':
				anID = node.right.value
#				print "createStepper( %s, %s)" % (aClass, anID )
				anEml.createStepper( aClass, anID )
			else:
				aSystemID = node.right.left.value
				aFullID = anEml.convertSystemID2SystemFullID(aSystemID)
				if aClass == 'System':
					anID = aFullID
				elif aClass == 'Substance':
					anID = 'Substance:' + aSystemID
				else:
					anID = 'Reactor:' + aSystemID
#				print "createEntity( %s, %s)" % ( aClass, anID )
				anEml.entity.append((aClass, anID))
				
				for i in anEml.queue:
					anEml.property.append((anID, i[1], i[2:]))
				anEml.queue = []

		if node.type == '{':
			aSystemID = node.left.value
			aFullID = anEml.convertSystemID2SystemFullID(aSystemID)
			
			aPropertyList = []
			(aPropertyName, aValueList) = ('', [] )
			nodekid = node.right
			while nodekid.value == ';':
				aValueList = []
				nodepro = nodekid.left.right
				while hasattr(nodepro, 'value'):
					aValueList.append(nodepro.value)
					nodepro = nodepro.right
				aPropertyName = nodekid.left.value
				anEml.queue.append((aFullID, aPropertyName, aValueList))
				nodekid = nodekid.right
		
		if node.type == ',':
			node.value = node.left.value
		else:
			node.value = node.attr
		
def sortSystemID( aList ):
	aSortList  = []
	aLowList   = []
	aHightList = []
	for i in aList:
		aClass = string.split(i[1], ':')[0]
		if aClass == 'System':
			aHightList.append(i)
		else:
			aLowList.append(i)
	aSortList = aHightList + aLowList
	return aSortList

if __name__ == '__main__':
	aFilename = sys.argv[1]
	aFile = open( aFilename )
	aScanner = ErScanner()
	aTokenList = aScanner.tokenize( aFile.read() )
#	print aTokenList
	aParser = ErParser()
	anAst = aParser.parse( aTokenList )

	aFileObject = open('minimum.eml')
	anEml = eml.Eml( aFileObject )
	anEml.entity = []
	anEml.property = []
	anEml.queue = []
	
	aInterpreter = Interpret( anAst )

	anEml.queue = []

	anEml.entity = sortSystemID(anEml.entity)

	for i in anEml.entity:
		(aClass, aFullID) = i
#		print "createEntity( %s, %s)" % (aClass, aFullID)
		anEml.createEntity(aClass, aFullID)

	for j in anEml.property:
		(aFullID, aPropertyName, aValueList) = j
#		print "setEntityProperty(%s, %s, %s)" % (aFullID, aPropertyName, aValueList)
		anEml.setEntityProperty(aFullID, aPropertyName, aValueList)
	
	string = anEml.asString()
	print string
#	print anAst
